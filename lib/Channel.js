// Generated by CoffeeScript 1.6.3
(function() {
  var Async, Channel, ConsumeParameters, Consumer, Message, PublishParameters, createLibMessage, getOptionsForPublish, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Async = require('async');

  Consumer = require('./Consumer');

  Message = require('./Message');

  getOptionsForPublish = function(params) {
    var key, options, val, _ref;
    options = {};
    _ref = params.message.properties;
    for (key in _ref) {
      if (!__hasProp.call(_ref, key)) continue;
      val = _ref[key];
      if (val != null) {
        options[key] = val;
      }
    }
    if (params.mandatory != null) {
      options.mandatory = params.mandatory;
    }
    return options;
  };

  createLibMessage = function(message) {
    return {
      fields: message.delivery,
      properties: message.properties,
      content: message.payload
    };
  };

  ConsumeParameters = (function() {
    function ConsumeParameters(properties) {
      if (properties == null) {
        properties = {};
      }
      this.noAck = properties.noAck;
      this.exclusive = properties.exclusive;
      this.priority = properties.priority;
      this["arguments"] = properties["arguments"];
      this.prefetch = properties.prefetch;
      this.queueName = properties.queueName;
      this.consumerTag = properties.consumerTag;
      this.handleMessage = properties.handleMessage;
      this.setDefaults();
    }

    ConsumeParameters.prototype.setDefaults = function() {
      if (this.prefetch == null) {
        this.prefetch = 1;
      }
      if (this.exclusive == null) {
        this.exclusive = false;
      }
      return this.noAck != null ? this.noAck : this.noAck = false;
    };

    return ConsumeParameters;

  })();

  PublishParameters = (function() {
    function PublishParameters(properties) {
      if (properties == null) {
        properties = {};
      }
      this.exchangeName = properties.exchangeName;
      this.routingKey = properties.routingKey;
      this.mandatory = properties.mandatory;
      this.setMessage(properties.message);
      this.setDefaults();
    }

    PublishParameters.prototype.setMessage = function(message) {
      if (message instanceof Message) {
        return this.message = message;
      }
      return this.message = new Message(message);
    };

    PublishParameters.prototype.setDefaults = function() {
      return this.mandatory != null ? this.mandatory : this.mandatory = false;
    };

    return PublishParameters;

  })();

  Channel = (function() {
    function Channel(properties) {
      if (properties == null) {
        properties = {};
      }
      this.wrapped = properties.wrapped;
    }

    Channel.prototype.assertExchange = function(exchange, callback) {
      return this.wrapped.assertExchange(exchange.name, exchange.type, exchange.options, function(error) {
        return callback(error);
      });
    };

    Channel.prototype.assertQueue = function(queue, callback) {
      return this.wrapped.assertQueue(queue.name, queue.options, function(error) {
        return callback(error);
      });
    };

    Channel.prototype.bindQueue = function(binding, callback) {
      return this.wrapped.bindQueue(binding.queueName, binding.exchangeName, binding.pattern, binding["arguments"], function(error) {
        return callback(error);
      });
    };

    Channel.prototype.assertSchema = function(schema, callback) {
      var assertExchange, assertExchanges, assertQueue, assertQueues, bindQueue, bindQueues, channel, steps;
      channel = this;
      assertExchange = function(exchange, done) {
        return channel.assertExchange(exchange, done);
      };
      assertQueue = function(queue, done) {
        return channel.assertQueue(queue, done);
      };
      bindQueue = function(binding, done) {
        return channel.bindQueue(binding, done);
      };
      assertExchanges = function(done) {
        return Async.eachSeries(schema.exchanges, assertExchange, done);
      };
      assertQueues = function(done) {
        return Async.eachSeries(schema.queues, assertQueue, done);
      };
      bindQueues = function(done) {
        return Async.eachSeries(schema.queueBindings, bindQueue, done);
      };
      steps = [assertExchanges, assertQueues, bindQueues];
      return Async.series(steps, callback);
    };

    Channel.prototype.publish = function(params) {
      var options;
      params = new PublishParameters(params);
      options = getOptionsForPublish(params);
      return this.wrapped.publish(params.exchangeName, params.routingKey, params.message.payload, options);
    };

    Channel.prototype.ack = function(message) {
      var amqpLibMessage;
      amqpLibMessage = createLibMessage(message);
      return this.wrapped.ack(amqpLibMessage);
    };

    Channel.prototype.nack = function(message, options) {
      var amqpLibMessage;
      if (options == null) {
        options = {};
      }
      if (options.requeue == null) {
        options.requeue = true;
      }
      amqpLibMessage = createLibMessage(message);
      return this.wrapped.nack(amqpLibMessage, false, options.requeue);
    };

    Channel.prototype.consume = function(params, callback) {
      var channel, consumer, handleConsume, options, proxyMessage;
      if (params == null) {
        params = {};
      }
      channel = this;
      params = new ConsumeParameters(params);
      consumer = new Consumer({
        channel: channel,
        queueName: params.queueName,
        consumerTag: params.consumerTag,
        handleMessage: params.handleMessage
      });
      proxyMessage = function(amqpLibMessage) {
        var message;
        message = new Message({
          payload: amqpLibMessage.content,
          properties: amqpLibMessage.properties,
          delivery: amqpLibMessage.fields
        });
        return consumer.handleMessage(message);
      };
      handleConsume = function(error, reply) {
        if (reply == null) {
          reply = {};
        }
        if (error != null) {
          return callback(error);
        }
        if (consumer.consumerTag == null) {
          consumer.consumerTag = reply.consumerTag;
        }
        return callback(null, consumer);
      };
      options = {
        noAck: params.noAck,
        exclusive: params.exclusive,
        priority: params.priority,
        "arguments": params["arguments"],
        consumerTag: params.consumerTag
      };
      this.wrapped.prefetch(params.prefetch);
      return this.wrapped.consume(params.queueName, proxyMessage, options, handleConsume);
    };

    Channel.prototype.cancel = function(consumerTag, callback) {
      return this.wrapped.cancel(consumerTag, function(error) {
        return callback(error);
      });
    };

    Channel.prototype.close = function(callback) {
      return this.wrapped.close(function(error) {
        return callback(error);
      });
    };

    return Channel;

  })();

  Channel.ConfirmChannel = (function(_super) {
    __extends(ConfirmChannel, _super);

    function ConfirmChannel() {
      _ref = ConfirmChannel.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    ConfirmChannel.prototype.publish = function(params, callback) {
      var options;
      params = new PublishParameters(params);
      options = getOptionsForPublish(params);
      return this.wrapped.publish(params.exchangeName, params.routingKey, params.message.payload, options, callback);
    };

    return ConfirmChannel;

  })(Channel);

  module.exports = Channel;

}).call(this);

/*
//@ sourceMappingURL=Channel.map
*/
